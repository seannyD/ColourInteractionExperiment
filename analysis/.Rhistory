anova(m0,m1,m2,m3)
summary(m3)
pdf("graphs/summary/PlateauTime_GenByCurvature.pdf", width=7, height=4)
par(mfrow=c(1,2))
plotmeans(prop.time.plateau~curvature, data = signals_MT[signals_MT$gen<3 ,], xlab = "Curvature", ylab="Proportion of time in Plateau", ylim=c(0.35,0.75), n.label=F)
plotmeans(prop.time.plateau~curvature, data = signals_MT[signals_MT$gen>8,], xlab = "Curvature", ylab="Proportion of time in Plateau", ylim=c(0.35,0.75), n.label=F)
dev.off()
par(mfrow=c(3,3))
for(i in 1:9){
plotmeans(prop.time.plateau~curvature, data=signals_MT[signals_MT$gen==i,],ylim=c(0.2,0.9))
}
par(mfrow=c(2,3))
for(i in unique(signals_MT$curvature)){
plotmeans(prop.time.plateau~gen, data=signals_MT[signals_MT$curvature==i,],ylim=c(0.2,0.9))
}
pdf("graphs/summary/PlateauTimeByGenerationByCurvature.pdf")
par(mfrow=c(1,1), bg='gray')
dx = signals_MT[signals_MT$chain2!="chain -174 log2.csv 0.4" & signals_MT$curvature %in% c(0,0.2,0.5),]
plot(c(1,10),c(0.4,0.7),type='n', xlab='Generation',ylab='Proportion of time in Plateau')
curvs = sort(unique(dx$curvature))
cols = heat.colors(3)
for(i in 1:length(curvs)){
dxx = dx[dx$curvature==curvs[i],]
p = tapply(dxx$prop.time.plateau, dxx$gen,mean)
g = as.numeric(names(p))
points(g,p,pch=16,col=cols[i])
lmx = lm(p~g)
abline(lmx, col = cols[i],lwd=3)
text(1,predict(lmx)[1], curvs[i],cex=2,col=cols[i], pos=3)
}
dev.off()
# Meaning 1 & 2- prediction: more steady sections with higher curvature
dx = signals_SONA
dx = dx[dx$meaning!=3,]
m0.zero = lmer(propZero~1  + (1|chain2) + (1|meaning), data=dx)
m1.zero = lmer(propZero~curvature + (1|chain2)+ (1|meaning), data=dx)
m2.zero = lmer(propZero~curvature+gen + (1|chain2)+ (1|meaning), data=dx)
m3.zero = lmer(propZero~curvature*gen + (1|chain2)+ (1|meaning), data=dx)
anova(m0.zero,m1.zero,m2.zero,m3.zero)
summary(m3.zero)
dx = signals_MT
dx = dx[dx$meaning!=3 & dx$curvature<0.4,]
m0.zero.mt = lmer(propZero~1  + (1|chain2)+ (1|meaning), data=dx)
m1.zero.mt = lmer(propZero~curvature + (1|chain2)+ (1|meaning), data=dx)
m2.zero.mt = lmer(propZero~curvature+gen + (1|chain2)+ (1|meaning), data=dx)
m3.zero.mt = lmer(propZero~curvature*gen + (1|chain2)+ (1|meaning), data=dx)
anova(m0.zero.mt,m1.zero.mt,m2.zero.mt,m3.zero.mt)
summary(m3.zero.mt)
###
dx = signals_MT
dx = dx[dx$meaning!=3,]
m0.plat = lmer(prop.time.plateau~1  + (1|chain2) + (1|meaning), data=dx)
m1.plat = lmer(prop.time.plateau~curvature + (1|chain2)+ (1|meaning), data=dx)
m2.plat = lmer(prop.time.plateau~curvature+gen + (1|chain2)+ (1|meaning), data=dx)
m3.plat = lmer(prop.time.plateau~curvature*gen + (1|chain2)+ (1|meaning), data=dx)
anova(m0.plat,m1.plat,m2.plat,m3.plat)
dx = signals_MT#[signals_MT$chain2!="chain -174 log2.csv 0.4",]
dx = dx
m0.plat = lmer(switches~1  + (1|chain2) , data=dx)
m1.plat = lmer(switches~I(log(curvature+0.1)) + (1|chain2), data=dx)
m2.plat = lmer(switches~I(log(curvature+0.1))+gen + (1|chain2), data=dx)
m3.plat = lmer(switches~I(log(curvature+0.1))*gen + (1|chain2), data=dx)
anova(m0.plat,m1.plat,m2.plat,m3.plat)
summary(m3.plat)
par(mfrow=c(2,3))
for(i in sort(unique(dx$curvature))){
plotmeans(switches~gen,data=dx[dx$curvature==i,],ylim=c(0,12))
}
par(mfrow=c(1,1))
pdf("graphs/summary/SwitchesByCurvature.pdf")
plotmeans(switches~curvature,data=dx,xlab='Curvature',ylab='Number of direction switches')
dev.off()
pdf("graphs/summary/SwitchesByCurvature_Gen1.pdf")
plotmeans(switches~curvature,data=dx[dx$gen==1,],xlab='Curvature',ylab='Number of direction switches',ylim=c(0,13))
dev.off()
pdf("graphs/summary/SwitchesByCurvature_Gen9.pdf")
plotmeans(switches~curvature,data=dx[dx$gen==9,],xlab='Curvature',ylab='Number of direction switches',ylim=c(0,13))
dev.off()
m0= lmer(switches.between.sections ~ 1 + (1|chain2) + (1 | meaning), data = dx)
m1= lmer(switches.between.sections ~ curvature + (1|chain2) + (1 | meaning), data = dx)
m2= lmer(switches.between.sections ~ curvature+gen + (1|chain2) + (1 | meaning), data = dx)
m3= lmer(switches.between.sections ~ curvature*gen + (1|chain2) + (1 | meaning), data = dx)
anova(m0,m1,m2,m3)
# CTree exploration
allData = rbind(signals_MT)#rbind(signals_MT,signals_SONA)
allData = allData[allData$meaning==3,]
allData = allData[,c("length","averageSlope","propZero",'switches','maxslope','slope.move','jerkyness','curvature','gen','meaning','run','prop.time.plateau')]
allData$run = as.factor(allData$run)
allData$meaning = as.factor(allData$meaning)
ctx = ctree(curvature ~ ., data=allData, controls=ctree_control(mincriterion = 0.1))
plot(ctx, terminal_panel=node_barplot)
#   steepness.sig.mean - the signal's average steepenss of curve
#   steepness.sig.mean.max - the signal's average steepenss of curve, where the steepenss is taken from the maximum curvature steepness, to normalise over curvature values
rm(list=ls())
library(dtw)
setwd("/Library/WebServer/Documents/ILMTurk/stats")
base = "../backup/June14/"
fdates = file.info(list.dirs("../backup/", recursive=F))
rownames(fdates) = gsub("//","/",rownames(fdates))
if(max(as.Date(fdates$mtime)) != as.Date(fdates[substr(base,1,nchar(base)-1),]$mtime)){
print("\n\n\n\n\nWARNING: NOT LATEST BACKUPS\n\n\n\n\n")
}
loadLog = function(folder,fn){
logAll = data.frame()
fns = list.files(path = paste(folder,"log/",sep=''), "*.csv" )
fns = fns[grepl("log",fns)]
for(fx in fns ){
if(file.size(paste(folder,"log/",fx,sep=''))>0){
log = read.csv(paste(folder,"log/",fx,sep=''),header=F,stringsAsFactors = F)
names(log) = c("chain","gen",'curvature','time','file','status',"X")
log = log[log$status %in% c("ready","completed"),]
log$genNum = sapply(log$gen,function(X){as.numeric(strsplit(X," ")[[1]][2])})
log$logFile = fx
logAll = rbind(logAll,log)
}
}
return(logAll)
}
getFiles = function(folder,filename){
fn = paste(folder,"outputLanguages/",filename,sep='')
if(file.exists((fn))){
dx =read.table(fn,stringsAsFactors = F,header=F,sep='\t')
sigs = sapply(dx[,1],function(X){sapply(strsplit(X,','),as.numeric)})
return(sigs)
} else{
print(paste("no data",filename))
return(data.frame(NA,NA,NA))
}
}
getResults = function(filename){
if(file.exists((filename))){
dx = read.table(filename,header=F,stringsAsFactors = F,sep='\t',fill=T)
dx = dx[dx[,1] == "Reproduction",]
dx = rev(dx)
dx = dx[!duplicated(dx$V2),]
physicalspace  = dx[order(dx$V2),]$V7
return(sapply(physicalspace,function(X){as.numeric(strsplit(X,',')[[1]])}))  # physical space
} else{
return(data.frame(NA,NA,NA))
}
}
plotSigs = function(sigs,physicalSpace = T){
lims = c(200,6000)
if(physicalSpace){
lims = c(0,1000)
}
lens = max(sapply(sigs,length))
plot(c(1,lens),lims,type='n',xaxt='n',yaxt='n',xlab='',ylab='')
for(X in 1:length(sigs)){
col = hsv(X/3,1,1,alpha=0.6)
lines(1:length(sigs[[X]]),sigs[[X]], col=col, lwd=3,)
}
}
plotLog = function(folder,log, runName=""){
for(details in unique(paste(log$logFile,log$chain,log$curvature, sep='_'))){
logfilex = strsplit(details,'_')[[1]][1]
chainx = strsplit(details,'_')[[1]][2]
curvx = strsplit(details,'_')[[1]][3]
lx = log[log$logFile == logfilex & log$chain==chainx & log$curvature==curvx,]
pdf(file=paste('graphs/signalPlots/',runName,"_",details,'.pdf',sep=''), width=4,height = 3 * nrow(lx))
par(mfrow=c(nrow(lx),1), mar=c(0.5,0.5,2,0.5))
for(i in 1:nrow(lx)){
#sigx = getFiles(folder,lx[i,]$file)
sigx = getResults(paste(folder,'results/',lx[i,]$file,sep=''))
plotSigs(sigx)
if(i == 1){
title(main=paste(runName,details))
}
}
dev.off()
}
}
processSignals = function(folder,log,runName =""){
signals = data.frame()
for(details in unique(paste(log$logFile,log$chain,log$curvature, sep='_'))){
logfilex = strsplit(details,'_')[[1]][1]
chainx = strsplit(details,'_')[[1]][2]
curvx = strsplit(details,'_')[[1]][3]
curvx2 = as.numeric(strsplit(curvx," ")[[1]][2])
lx = log[log$logFile == logfilex & log$chain==chainx & log$curvature==curvx,]
for(i in 1:nrow(lx)){
sigx = getResults(paste(folder,'results/',lx[i,]$file,sep=''))
sigd = sapply(sigx,sigStats, curvature=curvx2)
sigx.hz = getFiles(folder,lx[i,]$file) # Hz space
sigd.hz = sapply(sigx.hz,sigStats,get.steepness=F)
colnames(sigd) = paste("X",1:ncol(sigd))
colnames(sigd.hz) = paste("X",1:ncol(sigd.hz))
dx = data.frame(cbind(t(sigd),t(sigd.hz),
rep(logfilex,ncol(sigd)),
rep(chainx,ncol(sigd)),
rep(curvx,ncol(sigd)),
rep(runName,ncol(sigd)),
rep(lx[i,]$genNum,ncol(sigd)),
1:ncol(sigd),
paste(sapply(sigx,paste,collapse='_')),
paste(sapply(sigx.hz,paste,collapse='_'))
)
)
signals = rbind(signals,dx)
}
}
names(signals) = c('length','averageSlope','propZero','switches','maxslope','slope.move','jerkyness','prop.time.plateau','switches.between.sections','steepness.sig.mean','steepness.sig.mean.max','length.hz','averageSlope.hz','propZero.hz','switches.hz','maxslope.hz','slope.move.hz','jerkyness.hz','prop.time.plateau.hz','switches.between.sections.hz','steepness.sig.mean.hz','steepness.sig.mean.max.hz','logfile','chain','curvature','run','gen','meaning','physSignal','hzSignal')
signals$curvature = as.numeric(sapply(as.character(signals$curvature),function(X){strsplit(X," ")[[1]][2]}))
signals$length = as.numeric((as.character(signals$length)))
signals$maxslope = as.numeric((as.character(signals$maxslope)))
signals$averageSlope= as.numeric((as.character(signals$averageSlope)))
signals$propZero= as.numeric((as.character(signals$propZero)))
signals$switches= as.numeric((as.character(signals$switches)))
signals$slope.move= as.numeric((as.character(signals$slope.move)))
signals$jerkyness = as.numeric(as.character(signals$jerkyness))
signals$prop.time.plateau = as.numeric(as.character(signals$prop.time.plateau))
signals$switches.between.sections = as.numeric(as.character(signals$switches.between.sections))
signals$steepness.sig.mean = as.numeric(as.character(signals$steepness.sig.mean))
signals$steepness.sig.mean.max = as.numeric(as.character(signals$steepness.sig.mean.max))
signals$length.hz = as.numeric((as.character(signals$length.hz)))
signals$maxslope.hz = as.numeric((as.character(signals$maxslope.hz)))
signals$averageSlope.hz= as.numeric((as.character(signals$averageSlope.hz)))
signals$propZero.hz= as.numeric((as.character(signals$propZero.hz)))
signals$switches.hz= as.numeric((as.character(signals$switches.hz)))
signals$slope.move.hz= as.numeric((as.character(signals$slope.move.hz)))
signals$jerkyness.hz = as.numeric(as.character(signals$jerkyness.hz))
signals$prop.time.plateau.hz = as.numeric(as.character(signals$prop.time.plateau.hz))
signals$switches.between.sections.hz = as.numeric(as.character(signals$switches.between.sections.hz))
signals$steepness.sig.mean.hz = as.numeric(as.character(signals$steepness.sig.mean.hz))
signals$steepness.sig.mean.max.hz = as.numeric(as.character(signals$steepness.sig.mean.max.hz))
signals$physSignal = as.character(signals$physSignal)
signals$gen= as.numeric((as.character(signals$gen)))
signals$meaning= as.numeric((as.character(signals$meaning)))
signals$chain2 = paste(signals$chain,signals$logfile,signals$curvature)
return(signals)
}
sigStats = function(sig, curvature = 0,phys.breaks = c(-1,100,300,500,700,1001),get.steepness=T){
if(sum(!is.na(sig))==0){
return(rep(NA,11))
}
#- duration
lx = length(sig)
diffx = diff(sig)
# average slope change
slope = mean(abs(diffx))
slope.sd = sd(abs(diffx))
# averaage slope change excluding zero
slope.move = mean(abs(diffx[abs(diffx)>=5]))
if(is.nan(slope.move)){
slope.move = 0
}
# max slope change
maxslope = max(abs(diffx))
# proportion of signal with zero velocity
propzero = sum(diffx<5) / lx
# numer of direction changes
switchDirection = sum(abs((diff(diffx>=0))))
if(sum(!is.na(sig))==0){
prop.time.plateau = -1
switches.between.sections = -1
steepness.sig.mean = -1
} else{
segment.times = as.factor(as.character(cut(sig,breaks = phys.breaks,labels=c('plateau','steep','plateau','steep','plateau'))))
prop.time.plateau = sum(segment.times=='plateau')/length(segment.times)
sections =  paste(as.character(cut(sig,breaks = phys.breaks,labels=c('a','','c','','e'))), collapse='')
contiguous.sections = gsub("([aec])\\1+","\\1",sections)
switches.between.sections = nchar(contiguous.sections)-1
steepness.sig.mean = -1
steepness.sig.mean.max = -1
if(get.steepness){
# work out mean signal steepness
steepness.x = steepness[[1 + (curvature*10)]]
steepness.sig = steepness.x[sig]
steepness.sig.mean = mean(steepness.sig,na.rm=T)
# Work out mean signal steepness, with steepenss
#  defined as the maximum curvature steepenss
#  (to normalise the measure over curvatures)
steepness.x.max = steepness[[length(steepness)]]
steepness.sig.max = steepness.x.max[sig]
steepness.sig.mean.max = mean(steepness.sig.max,na.rm=T)
}
}
return(c(lx,slope,propzero,switchDirection,maxslope,slope.move,slope.sd,prop.time.plateau,switches.between.sections,steepness.sig.mean,steepness.sig.mean.max))
}
nonlinearCurve = read.csv("/Library/WebServer/Documents/ILMTurk/offline/TestThereminResults.csv")
steepness = list()
cxs = sort(unique(nonlinearCurve$curvature))
for(i in 1:length(cxs)){
sx = diff(nonlinearCurve[nonlinearCurve$curvature==cxs[i],]$hz)
sx = sx- min(sx)
sx = sx/ max(sx)
lx = cut(1:length(sx),breaks=seq(0,length(sx)+1,length.out=1001))
sx2 = tapply(sx,lx,mean)
steepness[[i]] = sx2
}
log_Nij = loadLog(paste(base,"fluteilm_NIJMEGEN/",sep=''),"log/log1.csv")
plotLog(paste(base,"fluteilm_NIJMEGEN/",sep=''),log_Nij,"Facebook")
signals_Nij = processSignals(paste(base,"fluteilm_NIJMEGEN/",sep=''), log_Nij)
signals_Nij = signals_Nij[complete.cases(signals_Nij[,-which(names(signals_Nij)=="prop.time.plateau.hz")]),]
log_MT = loadLog(paste(base,"fluteilm/",sep=''),"log/log1.csv")
plotLog(paste(base,"fluteilm/",sep=''),log_MT,"MTurk")
signals_MT = processSignals(paste(base,"fluteilm/",sep=''),log_MT)
signals_MT = signals_MT[complete.cases(signals_MT[,-which(names(signals_MT)=="prop.time.plateau.hz")]),]
tapply(log_MT$genNum,paste(log_MT$logFile,log_MT$chain,log_MT$curvature), max)
table(log_MT$genNum,log_MT$curvature)
sum(table(log_MT$genNum,log_MT$curvature))
log_SONA = loadLog(paste(base,"fluteilm_SONA/",sep=''),"log/log1.csv")
plotLog(paste(base,"fluteilm_SONA/",sep=''),log_SONA,"SONA")
signals_SONA = processSignals(paste(base,"fluteilm_SONA/",sep=''), log_SONA)
signals_SONA = signals_SONA[complete.cases(signals_SONA[,-which(names(signals_SONA)%in%c("prop.time.plateau.hz",'slope.move.hz'))]),]
table(log_SONA$genNum,log_SONA$curvature)
signals_MT$prop.time.plateau[signals_MT$prop.time.plateau==-1]  = NA
signals_SONA$prop.time.plateau[signals_SONA$prop.time.plateau==-1]  = NA
signals_Nij$prop.time.plateau[signals_Nij$prop.time.plateau==-1]  = NA
signals_MT$steepness.sig.mean[signals_MT$steepness.sig.mean==-1]  = NA
signals_SONA$steepness.sig.mean[signals_SONA$steepness.sig.mean==-1]  = NA
signals_Nij$steepness.sig.mean[signals_Nij$steepness.sig.mean==-1]  = NA
signals_MT$rawDataSource = base
signals_SONA$rawDataSource = base
signals_Nij$rawDataSource = base
write.csv(signals_Nij,"Data/Signals_Nij.csv",row.names=F)
write.csv(signals_MT,"Data/Signals_MT.csv",row.names=F)
write.csv(signals_SONA,"Data/Signals_SONA.csv",row.names=F)
---
title: "Colour experiment"
output: pdf_document
---
# Introduction
This analysis looks at the sign variants used in a colour naming game between signers of different sign languages meeting after 1 week of interaction and after 3 weeks of interaction.  The data was collected by Kang Suk Byun (Kang-Suk.Byun@mpi.nl).
The analysis tries to predict the relative frequency of each variant within a colour category in week 3, based on measures from week 1.
# Load libraries
```{r}
library(ggplot2)
library(lme4)
```
```{r echo=F}
setwd("~/Documents/MPI/KangSukColours/ColourExperiment/analysis/")
getMEText = function(r,ef, wald=NULL){
AIC = r[2,]$AIC
loglikDiff = signif(diff(r$logLik),2)
chi = round(r$Chisq[2],2)
df = r$`Chi Df`[2]
p = signif(r$`Pr(>Chisq)`[2],2)
wald.text = ""
if(!is.null(wald)){
est = signif(wald[1],2)
stder = signif(wald[2],2)
t = signif(wald[3],2)
wptext = ""
if(!is.na(wald[4])){
wptext = paste(", Wald p =",signif(wald[4],2))
}
wald.text = paste("beta = ",est,", std.err = ",stder, ", Wald t = ",t,wptext,';')
}
begin = 'There was no significant'
if(p <0.1){
begin = "There was a marginal"
}
if(p < 0.05){
begin = 'There was a significant'
}
return(paste(begin,ef,"(",wald.text,"log likelihood difference =",
loglikDiff,", df = ",df,", Chi Squared =", chi,", p = ",p,")."))
}
```
# Load data
```{r}
variants = read.csv('../data/processedData/variants_summary.csv', stringsAsFactors = F)
```
Transform some variables.
```{r}
variants$Teach = variants$Teach >0
variants$check.any = variants$check>0
variants$freq_week_1.logcenter = log(variants$freq_week_1 + 1)
variants$freq_week_1.logcenter =
variants$freq_week_1.logcenter - mean(variants$freq_week_1.logcenter)
# cut TryMarking into two categories
variants$TryMarked.cat = cut(variants$TryMarked,
c(-Inf,3,Inf),
labels = c("Low",'High'))
variants$averageLength_week_1.logcenter = log(variants$averageLength_week_1)
variants$averageLength_week_1.logcenter =
variants$averageLength_week_1.logcenter -
mean(variants$averageLength_week_1.logcenter)
```
---
title: "Colour experiment"
output: pdf_document
---
# Introduction
This analysis looks at the sign variants used in a colour naming game between signers of different sign languages meeting after 1 week of interaction and after 3 weeks of interaction.  The data was collected by Kang Suk Byun (Kang-Suk.Byun@mpi.nl).
The analysis tries to predict the relative frequency of each variant within a colour category in week 3, based on measures from week 1.
# Load libraries
```{r}
library(ggplot2)
library(lme4)
```
```{r echo=F}
setwd("~/Documents/MPI/KangSukColours/ColourExperiment/analysis/")
getMEText = function(r,ef, wald=NULL){
AIC = r[2,]$AIC
loglikDiff = signif(diff(r$logLik),2)
chi = round(r$Chisq[2],2)
df = r$`Chi Df`[2]
p = signif(r$`Pr(>Chisq)`[2],2)
wald.text = ""
if(!is.null(wald)){
est = signif(wald[1],2)
stder = signif(wald[2],2)
t = signif(wald[3],2)
wptext = ""
if(!is.na(wald[4])){
wptext = paste(", Wald p =",signif(wald[4],2))
}
wald.text = paste("beta = ",est,", std.err = ",stder, ", Wald t = ",t,wptext,';')
}
begin = 'There was no significant'
if(p <0.1){
begin = "There was a marginal"
}
if(p < 0.05){
begin = 'There was a significant'
}
return(paste(begin,ef,"(",wald.text,"log likelihood difference =",
loglikDiff,", df = ",df,", Chi Squared =", chi,", p = ",p,")."))
}
```
# Load data
```{r}
variants = read.csv('../data/processedData/variants_summary.csv', stringsAsFactors = F)
```
Transform some variables.
```{r}
variants$Teach = variants$Teach >0
variants$check.any = variants$check>0
variants$freq_week_1.logcenter = log(variants$freq_week_1 + 1)
variants$freq_week_1.logcenter =
variants$freq_week_1.logcenter - mean(variants$freq_week_1.logcenter)
# cut TryMarking into two categories
variants$TryMarked.cat = cut(variants$TryMarked,
c(-Inf,3,Inf),
labels = c("Low",'High'))
variants$averageLength_week_1.logcenter = log(variants$averageLength_week_1)
variants$averageLength_week_1.logcenter =
variants$averageLength_week_1.logcenter -
mean(variants$averageLength_week_1.logcenter)
```
# Ctree
```{r}
ct =  ctree()
```
# LMER models
```{r modelBits}
m0 = lmer(freq_week_4_withinColour ~
1
+ (1 | colourName),
data=variants)
m1 = lmer(freq_week_4_withinColour ~
(indexical) +
+ (1 | colourName),
data=variants)
m2 = lmer(freq_week_4_withinColour ~
(indexical) +
(Teach)
+ (1 | colourName),
data=variants)
m3 = lmer(freq_week_4_withinColour ~
(indexical) +
(Teach) + (TryMarked.cat)
+ (1 | colourName),
data=variants)
m4 = lmer(freq_week_4_withinColour ~
(indexical) +
Teach * TryMarked.cat
+ (1 | colourName),
data=variants)
m5 = lmer(freq_week_4_withinColour ~
(indexical) +
(Teach * TryMarked.cat) +
freq_week_1.logcenter
+ (1 | colourName),
data=variants)
m6 = lmer(freq_week_4_withinColour ~
(indexical) +
(Teach * TryMarked.cat) +
freq_week_1.logcenter +
averageLength_week_1.logcenter
+ (1 | colourName),
data=variants)
m7 = lmer(freq_week_4_withinColour ~
(indexical) +
(Teach * TryMarked.cat) +
freq_week_1.logcenter +
averageLength_week_1.logcenter+
check.any
+ (1 | colourName),
data=variants)
```
# Results
```{r}
anova(m0,m1,m2,m3,m4,m5, m6,m7)
anova(m0,m1,m2,m3,m4,m5, m6,m7)
anova(m0,m1,m2,m3,m4,m5, m6,m7)
summary(m4)
ct =  ctree(freq_week_4_withinColour ~
(indexical) +
(Teach +TryMarked.cat) +
freq_week_1.logcenter +
averageLength_week_1.logcenter+
check.any, data=variants)
ct =  ctree(freq_week_4_withinColour ~
factor(indexical) +
(factor(Teach) +factor(TryMarked.cat)) +
freq_week_1.logcenter +
averageLength_week_1.logcenter+
factor(check.any), data=variants)
plot(ct)
